#!/usr/bin/env python
##
# getstatic-mini.py
# github.com/deadbits
# very stripped down version of getstatic.py
# quickly display basic file information for a single sample or
# a directory of samples. written to display data in the format
# i use for reports so i can just run this, copy-pasta, woooo.
#
# displays:
#   name, md5, sha1, sha256, type, size, ssdeep,
#   arch, entry point, compile time, start address
# optionally run hachoir-subfile against the files
##

import os
import sys
import hashlib
import commands
import datetime
import platform
import argparse

try:
    from ordereddict import OrderedDict
except ImportError:
    print 'error: python library ordereddict is required\nrun `pip install ordereddict` to install.'
    sys.exit(1)

try:
    import pefile
except ImportError:
    print 'error: python library pefile is required\nrun `pip install pefile` to install.'
    sys.exit(1)


def check_subfile(file_name):
    out = commands.getoutput('hachoir-subfile %s' % file_name)
    if len(out.splitlines()) > 5:
        for l in out.splitlines():
            if 'File at' in l:
                if not 'File at 0 size=' in l:
                    print l


def check_path(path):
    if not os.path.exists(path):
        print 'path %s is not valid. you had one job!' % path
        sys.exit(1)


def get_ssdeep(file_name):
    try:
        from ssdeep import ssdeep
        ss = ssdeep()
        return ss.hash_file(file_name)
    except ImportError:
        try:
            import ssdeep
            return ssdeep.hash_from_file(file_name)
        except ImportError:
            print 'error: no library `ssdeep` available for import! this feature will not be available.'
            return None


def grep_saddress(file_name):
    out = commands.getoutput('%s -x %s | grep "start address"' % (objdump, file_name))
    if out != '\n':
        try:
            sa = out.split('start address')[1]
        except IndexError:
            return None
        return sa
    return None


def get_hash(f, hash_type):
    fin = open(f, 'rb')
    if hash_type == 'md5':
        m = hashlib.md5()
    elif hash_type == 'sha1':
        m = hashlib.sha1()
    elif hash_type == 'sha256':
        m = hashlib.sha256()
    while True:
        data = fin.read(8192)
        if not data:
            break
        m.update(data)
    return m.hexdigest()


def scan_file(file_name, subfile):
    # start analysis with basic info
    pe = pefile.PE(file_name)
    machine = pe.FILE_HEADER.Machine
    all_results = OrderedDict( [
        ('MD5',             get_hash(file_name, 'md5')),
        ('SHA1',            get_hash(file_name, 'sha1')),
        ('SHA256',          get_hash(file_name, 'sha256')),
        ('Type',            commands.getoutput('file %s' % file_name).split(file_name + ': ')[1]),
        ('Size',            (os.path.getsize(file_name))/1000),
        ('SSDeep',          get_ssdeep(file_name)),
        #('ImpHash',        pe.get_imphash()),
        ('Arch',            pefile.MACHINE_TYPE[machine]),
        ('Entry Point',     hex(pe.OPTIONAL_HEADER.AddressOfEntryPoint)),
        ('Compiled',        datetime.datetime.fromtimestamp(pe.FILE_HEADER.TimeDateStamp)),
        ('Start Address',   grep_saddress(file_name))
    ] )

    print '\n[ %s ]' % file_name
    for key, value in all_results.iteritems():
        if key == 'Compiled' or key == 'Entry Point' or key == 'Start Address':
            print '%s:\t\t%s' % (key, value)
        else:
            print '%s:\t\t\t%s' % (key, value)

    if subfile:
        print '\n'
        check_subfile(file_name)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='perform static analysis against an individual executable or an entire directory of executables')
    parser.add_argument('-f', '--file', help='individual file name to assess')
    parser.add_argument('-d', '--dir', help='scan every file in directory')
    parser.add_argument('-s', '--subfile', help='run hachoir-subfile', action='store_true', default=False)
    args = parser.parse_args()

    if platform.system() == 'Darwin':
        objdump = 'gobjdump'
    elif platform.system() == 'Linux':
        objdump = 'objdump'
    else:
        print 'error: sorry. blame Windows.'
        sys.exit(1)

    if args.dir:
        if args.file:
            print 'the flags --file and --dir may not be used together.\nwhy would you even try that?'
            sys.exit(1)
        check_path(args.dir)
        dir_name = (args.dir).rstrip('/')
        expanded = os.listdir(dir_name)
        for path in expanded:
            full_path = dir_name + '/' + path
            out = commands.getoutput('file %s' % full_path)
            if 'PE' in out:
                # wow this is bad.
                if 'executable' in out:
                    scan_file(full_path, subfile=args.subfile)
                else:
                    print 'skipping %s' % full_path

    if args.file:
        file_name = args.file
        check_path(args.file)
        scan_file(file_name, subfile=args.subfile)


